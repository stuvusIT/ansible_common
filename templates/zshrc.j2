# {{ ansible_managed }}
# Sensible zshrc
#
# Switch to application mode for keyboard
printf '\e[?1h';

# Coreutils
export LS_COLORS=':no=00;37:fi=00;37:di=00;36:ln=00;35:pi=01;33:so=01;32:bd=01;35:cd=01;37:mi=00;31:or=01;30:ex=00;31:do=01;32:su=00;37;41:sg=00;37;45:st=00;37;44:ow=00;36;41:tw=00;36;44:ca=00;31;46:mh='
alias ls='ls -h --color --group-directories-first -F'
alias ll='ls -lF'
alias la='ll -a'
alias rm='rm -I' # Less intrusive interactive mode

# Directories
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias -- -='cd -'
mkcd() {
	[ "${1}" ] || return 0
	[ -d "${1}" ] || mkdir -vp "${1}"
	[ -d "${1}" ] || builtin cd "${1}"
}

# ZSH stuff
export PS1=$'%(!.%{\e[1;31m%}%n@%m%{\e[0m%}.%{\e[0;34m%}%n@%m%{\e[0m%}):%~ %(!.#.$) ' # user@host:~/dir$ (blue for user, red for privileged)
setopt auto_pushd # cd behaves like pushd
setopt pushd_to_home # pushd with no arguments -> pushd $HOME
setopt auto_param_keys # Be smarter when completing whithin parameters
setopt auto_param_slash # Add / after completed directories
setopt auto_remove_slash # When autocomplete adds a slash and you do as well, one will be removed
setopt complete_aliases # Make aliases a distinct command
setopt complete_in_word # Tab completion in word
setopt menu_complete # Show menu
setopt no_list_beep # No beep when completion list is displayed
setopt brace_ccl # Expand stuff like {0-9} {a-z}
setopt glob # Perform filename generation (globbing)
setopt mark_dirs # Append trailing / to all globbed directories
setopt nomatch # Warn when nothing matched
setopt rc_expand_param # foo=(a b c); foo${foo}bar -> fooabar foobbar foocbar
setopt rematch_pcre # =~ will use PCRE expressions
setopt append_history # Append to history instead of replacing it
setopt hist_fcntl_lock # Use fcntl to lock history while writing
setopt hist_ignore_dups # Do not add to history if the same as previos command
setopt hist_ignore_space # Do not add to history if command contains a leading space
setopt hist_reduce_blanks # Remove superflous blanks
setopt correct # Try to correct spelling of commands
setopt interactive_comments # Allow comments in interactive shells
setopt print_exit_value # Print exit value if $? != 0
setopt rm_star_silent # Do not warn when executing rm *
setopt check_jobs # Remind user of remaining jobs when quitting
setopt long_list_jobs # List jobs in long format by default
# No lag
KEYTIMEOUT=1
# History with arrow keys
[[ "${terminfo[kpp]}" != "" ]] && bindkey "${terminfo[kpp]}" up-line-or-history
[[ "${terminfo[knp]}" != "" ]] && bindkey "${terminfo[knp]}" down-line-or-history
# Home and End keys
[[ "${terminfo[khome]}" != "" ]] && bindkey "${terminfo[khome]}" beginning-of-line
[[ "${terminfo[kend]}" != "" ]] && bindkey "${terminfo[kend]}"  end-of-line
# Delete key
[[ "${terminfo[kdch1]}" != "" ]] && bindkey "${terminfo[kdch1]}" delete-char
# Ctrl+Arrow
bindkey '^[[1;5C' forward-word
bindkey '^[[1;5D' backward-word
# History with Ctrl+R
bindkey "^r" history-incremental-search-backward
# Arrow keys for non-empty buffer
if [[ "${terminfo[kcuu1]}" != "" ]]; then
	autoload -U up-line-or-beginning-search
	zle -N up-line-or-beginning-search
	bindkey "${terminfo[kcuu1]}" up-line-or-beginning-search
fi
if [[ "${terminfo[kcud1]}" != "" ]]; then
	autoload -U down-line-or-beginning-search
	zle -N down-line-or-beginning-search
	bindkey "${terminfo[kcud1]}" down-line-or-beginning-search
fi
# Completion menu
[[ "${terminfo[kcbt]}" != "" ]] && bindkey "${terminfo[kcbt]}" reverse-menu-complete
# Do nothing with the scroll wheel
nop() { : }
zle -N nop
bindkey ^Y nop
bindkey ^E nop
# Initialize completions with dump
autoload -Uz compinit
compinit -i -d "${HOME}/.cache/zsh/zcompdump-${SHORT_HOST}-${ZSH_VERSION}"
# Automatically rehash
zstyle ':completion:*' rehash true
# Case insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|=*' 'l:|=* r:|=*'
# Completion cache
zstyle ':completion::complete:*' use-cache 1
zstyle ':completion::complete:*' cache-path "${HOME}/.cache/zsh"
# Tabbable menu
zstyle ':completion:*' menu select
# Proper cd completion
zstyle ':completion:*:cd:*' tag-order local-directories directory-stack path-directories
# ls colors
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
# ps colors
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=01;93=0=01'
zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,comm -w -w"
HISTFILE=~/.zhistory
HISTSIZE=10000
SAVEHIST=10000

# Software
export EDITOR=vim
export SYSTEMD_EDITOR="${EDITOR}"
export PAGER=less
alias more="${PAGER}"
alias zless="${PAGER}"
alias vimpager="${PAGER}"
alias vi=vim
alias v=vim

# Misc. stuff
alias sudo='sudo ' # Allows alias in sudo
alias dd='dd status=progress'
alias lsblk='lsblk -o NAME,MAJ:MIN,SIZE,TYPE,UUID,LABEL,FSTYPE,MOUNTPOINT'
alias tree='tree -I .git -FC'
alias grep='grep --color=auto --exclude-dir={.bzr,.CVS,.git,.hg,.svn}'

###############
## Key configuration
###############

# vi keybindings
bindkey -v

# No lag when switching vi modes (0.1 secs)
KEYTIMEOUT=1

# Arrow up for history
if [[ "${terminfo[kpp]}" != "" ]]; then
        bindkey "${terminfo[kpp]}" up-line-or-history
fi

# Arrow down for history
if [[ "${terminfo[knp]}" != "" ]]; then
        bindkey "${terminfo[knp]}" down-line-or-history
fi

# Arrow up with non-empty buffer
if [[ "${terminfo[kcuu1]}" != "" ]]; then
        autoload -U up-line-or-beginning-search
        zle -N up-line-or-beginning-search
        bindkey "${terminfo[kcuu1]}" up-line-or-beginning-search
fi

# Arrow down with non-empty buffer
if [[ "${terminfo[kcud1]}" != "" ]]; then
        autoload -U down-line-or-beginning-search
        zle -N down-line-or-beginning-search
        bindkey "${terminfo[kcud1]}" down-line-or-beginning-search
fi

# Home key
if [[ "${terminfo[khome]}" != "" ]]; then
        bindkey "${terminfo[khome]}" beginning-of-line
fi

# End key
if [[ "${terminfo[kend]}" != "" ]]; then
        bindkey "${terminfo[kend]}"  end-of-line
fi

# Space does history expansion
bindkey ' ' magic-space

# Ctrl+Arrow to move by word
bindkey '^[[1;5C' forward-word
bindkey '^[[1;5D' backward-word

# Move through completion backwards with Shift+Tab
if [[ "${terminfo[kcbt]}" != "" ]]; then
        bindkey "${terminfo[kcbt]}" reverse-menu-complete
fi

# Backspace to delete backwards
bindkey '^?' backward-delete-char

# Delete to delete forward
if [[ "${terminfo[kdch1]}" != "" ]]; then
        bindkey "${terminfo[kdch1]}" delete-char
else
        bindkey "^[[3~" delete-char
        bindkey "^[3;5~" delete-char
        bindkey "\e[3~" delete-char
fi

# Ctrl+R for backward search
bindkey "^r" history-incremental-search-backward

# v command for opening in $EDITOR
bindkey -M vicmd v edit-command-line

# b command to push line
bindkey -M vicmd b push-line-or-edit

# Do nothing when using scroll wheel
nop() {
        :
}
zle -N nop
bindkey ^Y nop
bindkey ^E nop
